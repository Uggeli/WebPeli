<!DOCTYPE html>
<html>
<head>
    <title>WebPeli Client</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #gameCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="debugInfo"></div>

    <script src="/game-client.js"></script>
    <script>
        // Game renderer
        class GameRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.tileSize = 32; // Size of each tile in pixels
                this.camera = { x: 0, y: 0 };
                this.debugElement = document.getElementById('debugInfo');
                
                // Initialize size
                this.resize();
                
                // Handle window resize
                window.addEventListener('resize', () => this.resize());
                
                // Handle keyboard input
                window.addEventListener('keydown', (e) => this.handleKeyPress(e));
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Request new viewport data after resize
                this.requestViewport();
            }
            
            handleKeyPress(e) {
                const moveSpeed = 32; // Pixels per keypress
                
                switch(e.key) {
                    case 'ArrowUp':
                        this.camera.y -= moveSpeed;
                        break;
                    case 'ArrowDown':
                        this.camera.y += moveSpeed;
                        break;
                    case 'ArrowLeft':
                        this.camera.x -= moveSpeed;
                        break;
                    case 'ArrowRight':
                        this.camera.x += moveSpeed;
                        break;
                }
                
                this.requestViewport();
            }
            
            requestViewport() {
                if (this.client) {
                    const viewportWidth = Math.ceil(this.canvas.width / this.tileSize);
                    const viewportHeight = Math.ceil(this.canvas.height / this.tileSize);
                    
                    this.client.requestViewport(
                        this.camera.x,
                        this.camera.y,
                        viewportWidth,
                        viewportHeight
                    );
                    
                    // Update debug info
                    this.debugElement.textContent = 
                        `Camera: (${this.camera.x}, ${this.camera.y})\n` +
                        `Viewport: ${viewportWidth}x${viewportHeight}`;
                }
            }
            
            setClient(client) {
                this.client = client;
                
                client.onViewportData(({width, height, grid}) => {
                    this.renderViewport(width, height, grid);
                });
            }
            
            renderViewport(width, height, grid) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const tile = grid[y * width + x];
                        this.renderTile(x, y, tile);
                    }
                }
            }
            
            renderTile(x, y, tileType) {
                // Simple color mapping for now
                const colors = {
                    0: '#000000', // Empty
                    1: '#8B4513', // Dirt
                    2: '#808080', // Stone
                    3: '#8B7355', // Wood
                    4: '#C0C0C0', // Metal
                    5: '#E0FFFF', // Ice
                    6: '#F4A460', // Sand
                    8: '#0000FF', // Water
                    9: '#FF4500', // Lava
                    10: '#FFFFFF', // Snow
                    12: '#8B0000', // Blood
                    13: '#654321', // Mud
                };
                
                const color = colors[tileType] || '#FF00FF'; // Magenta for unknown tiles
                
                this.ctx.fillStyle = color;
                this.ctx.fillRect(
                    x * this.tileSize,
                    y * this.tileSize,
                    this.tileSize,
                    this.tileSize
                );
                
                // Draw grid lines
                this.ctx.strokeStyle = '#333333';
                this.ctx.strokeRect(
                    x * this.tileSize,
                    y * this.tileSize,
                    this.tileSize,
                    this.tileSize
                );
            }
        }
        
        // Initialize game
        async function initGame() {
            const renderer = new GameRenderer(document.getElementById('gameCanvas'));
            
            // Create and connect client
            const client = new GameClient('ws://' + window.location.host + '/ws');
            await client.connect();
            
            // Set client in renderer
            renderer.setClient(client);
            
            // Request initial viewport
            renderer.requestViewport();
        }
        
        // Start game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>